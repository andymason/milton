(() => {
  let __assign = Object.assign;

  // src/constants.ts
  var STAGES;
  (function(STAGES2) {
    STAGES2[STAGES2["CHOOSE_FRAMES"] = 0] = "CHOOSE_FRAMES";
    STAGES2[STAGES2["PREVIEW_OUTPUT"] = 1] = "PREVIEW_OUTPUT";
    STAGES2[STAGES2["RESPONSIVE_PREVIEW"] = 2] = "RESPONSIVE_PREVIEW";
    STAGES2[STAGES2["SAVE_OUTPUT"] = 3] = "SAVE_OUTPUT";
  })(STAGES || (STAGES = {}));
  var MSG_EVENTS;
  (function(MSG_EVENTS2) {
    MSG_EVENTS2[MSG_EVENTS2["DOM_READY"] = 0] = "DOM_READY";
    MSG_EVENTS2[MSG_EVENTS2["NO_FRAMES"] = 1] = "NO_FRAMES";
    MSG_EVENTS2[MSG_EVENTS2["FOUND_FRAMES"] = 2] = "FOUND_FRAMES";
    MSG_EVENTS2[MSG_EVENTS2["RESIZE"] = 3] = "RESIZE";
    MSG_EVENTS2[MSG_EVENTS2["RENDER"] = 4] = "RENDER";
    MSG_EVENTS2[MSG_EVENTS2["CLOSE"] = 5] = "CLOSE";
    MSG_EVENTS2[MSG_EVENTS2["ERROR"] = 6] = "ERROR";
    MSG_EVENTS2[MSG_EVENTS2["UPDATE_HEADLINES"] = 7] = "UPDATE_HEADLINES";
    MSG_EVENTS2[MSG_EVENTS2["COMPRESS_IMAGE"] = 8] = "COMPRESS_IMAGE";
    MSG_EVENTS2[MSG_EVENTS2["COMPRESSED_IMAGE"] = 9] = "COMPRESSED_IMAGE";
  })(MSG_EVENTS || (MSG_EVENTS = {}));
  var OUTPUT_FORMATS;
  (function(OUTPUT_FORMATS2) {
    OUTPUT_FORMATS2[OUTPUT_FORMATS2["INLINE"] = 0] = "INLINE";
    OUTPUT_FORMATS2[OUTPUT_FORMATS2["IFRAME"] = 1] = "IFRAME";
  })(OUTPUT_FORMATS || (OUTPUT_FORMATS = {}));
  var HEADLINE_NODE_NAMES;
  (function(HEADLINE_NODE_NAMES2) {
    HEADLINE_NODE_NAMES2["HEADLINE"] = "headline";
    HEADLINE_NODE_NAMES2["SUBHEAD"] = "subhead";
    HEADLINE_NODE_NAMES2["SOURCE"] = "source";
  })(HEADLINE_NODE_NAMES || (HEADLINE_NODE_NAMES = {}));

  // src/index.tsx
  figma.ui.on("message", (e) => handleReceivedMsg(e));
  figma.showUI(__html__);
  const {width, height} = figma.viewport.bounds;
  const {zoom} = figma.viewport;
  const initialWindowWidth = Math.round(width * zoom);
  const initialWindowHeight = Math.round(height * zoom);
  figma.ui.resize(initialWindowWidth, initialWindowHeight);
  const compressionPool = [];
  function handleCompressedMsg(msg) {
    const {uid, image} = msg;
    const poolItemIndex = compressionPool.findIndex((item) => item.uid === uid);
    if (poolItemIndex > -1) {
      compressionPool[poolItemIndex].callback(image);
      clearTimeout(compressionPool[poolItemIndex].timeout);
      compressionPool.splice(poolItemIndex, 1);
    }
  }
  function getRootFrames() {
    const {currentPage} = figma;
    const rootFrames = currentPage.children.filter((node) => node.type === "FRAME");
    if (rootFrames.length < 1) {
      console.warn("No frames");
      figma.ui.postMessage({type: MSG_EVENTS.NO_FRAMES});
      return;
    }
    const headlinesAndSource = getHeadlinesAndSource(currentPage);
    const framesData = rootFrames.map((frame) => {
      const {name, width: width2, height: height2, id} = frame;
      const textNodes = getTextNodes(frame);
      return {
        name,
        width: width2,
        height: height2,
        id,
        textNodes,
        responsive: false,
        selected: true
      };
    });
    figma.ui.postMessage(__assign({
      type: MSG_EVENTS.FOUND_FRAMES,
      frames: framesData,
      windowWidth: initialWindowWidth,
      windowHeight: initialWindowHeight
    }, headlinesAndSource));
  }
  function compressImage(node) {
    const newFills = [];
    return new Promise((resolve, _reject) => {
      const fills = node.fills === figma.mixed ? [] : [...node.fills];
      Promise.all(fills.map(async (paint) => {
        if (paint.type === "IMAGE" && paint.imageHash) {
          const image = figma.getImageByHash(paint.imageHash);
          const imageBytes = await image.getBytesAsync();
          const uid = Math.random().toString(32);
          figma.ui.postMessage({
            type: MSG_EVENTS.COMPRESS_IMAGE,
            image: imageBytes,
            width: node.width,
            height: node.height,
            uid
          });
          await new Promise((res) => {
            const timeout = setTimeout(() => {
              _reject("Compress image response timed out.");
            }, 5e3);
            compressionPool.push({
              uid,
              callback: (image2) => {
                const newPaint = JSON.parse(JSON.stringify(paint));
                newPaint.imageHash = figma.createImage(image2).hash;
                newFills.push(newPaint);
                res();
              },
              timeout
            });
          });
        }
      })).then(() => {
        node.fills = newFills;
        resolve();
      });
    });
  }
  async function handleRender(frameId) {
    let clone;
    try {
      const frame = figma.getNodeById(frameId);
      if (!frame || frame.type !== "FRAME") {
        throw new Error("Missing frame");
      }
      clone = frame.clone();
      clone.name = `[temp] ${frame.name}`;
      const cloneTextNodes = clone.findChildren((node) => node.type === "TEXT");
      cloneTextNodes.forEach((node) => node.remove());
      const nodesWithPaintImages = clone.findChildren((node) => {
        if ("fills" in node && node.fills !== figma.mixed) {
          return node.fills.some((fill) => "imageHash" in fill);
        } else {
          return false;
        }
      });
      await Promise.all(nodesWithPaintImages.map(compressImage));
      if (nodesWithPaintImages.length > 0) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
      }
      console.log("RENDERING SVG");
      const svg = await clone.exportAsync({
        format: "SVG",
        svgOutlineText: false,
        svgSimplifyStroke: true
      });
      figma.ui.postMessage({
        type: MSG_EVENTS.RENDER,
        frameId,
        svg
      });
    } catch (err) {
      figma.ui.postMessage({
        type: MSG_EVENTS.ERROR,
        errorText: `Render failed: ${err == null ? void 0 : err.message}`
      });
    } finally {
      console.warn("Inside render finallay");
      clone == null ? void 0 : clone.remove();
    }
  }
  function getTextNodes(frame) {
    const textNodes = frame.findAll(({type}) => type === "TEXT");
    const {absoluteTransform} = frame;
    const rootX = absoluteTransform[0][2];
    const rootY = absoluteTransform[1][2];
    return textNodes.map((node) => {
      const {absoluteTransform: absoluteTransform2, width: width2, height: height2, fontSize: fontSizeData, fontName, fills, characters, lineHeight, letterSpacing, textAlignHorizontal, textAlignVertical} = node;
      const textX = absoluteTransform2[0][2];
      const textY = absoluteTransform2[1][2];
      const x = textX - rootX;
      const y = textY - rootY;
      const [fill] = fills === figma.mixed ? [] : fills;
      let colour = {r: 0, g: 0, b: 0, a: 1};
      if (fill.type === "SOLID") {
        colour = __assign(__assign({}, colour), {a: fill.opacity || 1});
      }
      let fontSize = 16;
      if (fontSizeData !== figma.mixed) {
        fontSize = fontSizeData;
      }
      let fontFamily = "Arial";
      let fontStyle = "Regular";
      if (fontName !== figma.mixed) {
        fontFamily = fontName.family;
        fontStyle = fontName.style;
      }
      return {
        x,
        y,
        width: width2,
        height: height2,
        fontSize,
        fontFamily,
        fontStyle,
        colour,
        characters,
        lineHeight,
        letterSpacing,
        textAlignHorizontal,
        textAlignVertical
      };
    });
  }
  function getHeadlinesAndSource(pageNode) {
    const NODE_NAMES = ["headline", "subhead", "source"];
    const result = {};
    for (const name of NODE_NAMES) {
      const node = pageNode.findChild((node2) => node2.name === name && node2.type === "TEXT");
      result[name] = node == null ? void 0 : node.characters;
    }
    return result;
  }
  async function setHeadlinesAndSource(props) {
    const {pageNode} = props;
    const frames = pageNode.findChildren((node) => node.type === "FRAME");
    const mostLeftPos = Math.min(...frames.map((node) => node.x));
    const mostTopPos = Math.min(...frames.map((node) => node.y));
    Object.values(HEADLINE_NODE_NAMES).forEach(async (name, _i) => {
      let node = pageNode.findChild((node2) => node2.name === name && node2.type === "TEXT");
      const textContent = props[name];
      if (!textContent) {
        if (node)
          node.remove();
        return;
      }
      if (!node) {
        node = figma.createText();
        node.name = name;
        let y = mostTopPos - 60;
        if (name === HEADLINE_NODE_NAMES.HEADLINE) {
          y -= 60;
        } else if (name === HEADLINE_NODE_NAMES.SUBHEAD) {
          y -= 30;
        }
        node.relativeTransform = [
          [1, 0, mostLeftPos],
          [0, 1, y]
        ];
      }
      node.locked = true;
      const fontName = node.fontName !== figma.mixed ? node.fontName.family : "Roboto";
      const fontStyle = node.fontName !== figma.mixed ? node.fontName.style : "Regular";
      await figma.loadFontAsync({family: fontName, style: fontStyle});
      node.characters = props[name] || "";
    });
  }
  function handleReceivedMsg(msg) {
    switch (msg.type) {
      case MSG_EVENTS.ERROR:
        console.log("plugin msg: error");
        break;
      case MSG_EVENTS.CLOSE:
        console.log("plugin msg: close");
        figma.closePlugin();
        break;
      case MSG_EVENTS.DOM_READY:
        console.log("plugin msg: DOM READY");
        getRootFrames();
        break;
      case MSG_EVENTS.RENDER:
        console.log("plugin msg: render", msg.frameId);
        handleRender(msg.frameId);
        break;
      case MSG_EVENTS.RESIZE:
        console.log("plugin msg: resize");
        figma.ui.resize(msg.width, msg.height);
        break;
      case MSG_EVENTS.UPDATE_HEADLINES:
        setHeadlinesAndSource({
          pageNode: figma.currentPage,
          headline: msg.headline,
          subhead: msg.subhead,
          source: msg.source
        });
        break;
      case MSG_EVENTS.COMPRESSED_IMAGE:
        handleCompressedMsg(msg);
        break;
      default:
        console.error("Unknown post message", msg);
    }
  }
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL2NvbnN0YW50cy50cyIsICJzcmMvaW5kZXgudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJleHBvcnQgZW51bSBTVEFHRVMge1xuICBDSE9PU0VfRlJBTUVTLFxuICBQUkVWSUVXX09VVFBVVCxcbiAgUkVTUE9OU0lWRV9QUkVWSUVXLFxuICBTQVZFX09VVFBVVCxcbn1cblxuZXhwb3J0IGVudW0gTVNHX0VWRU5UUyB7XG4gIERPTV9SRUFEWSxcbiAgTk9fRlJBTUVTLFxuICBGT1VORF9GUkFNRVMsXG4gIFJFU0laRSxcbiAgUkVOREVSLFxuICBDTE9TRSxcbiAgRVJST1IsXG4gIFVQREFURV9IRUFETElORVMsXG4gIENPTVBSRVNTX0lNQUdFLFxuICBDT01QUkVTU0VEX0lNQUdFLFxufVxuXG5leHBvcnQgZW51bSBPVVRQVVRfRk9STUFUUyB7XG4gIElOTElORSxcbiAgSUZSQU1FLFxufVxuXG5leHBvcnQgY29uc3QgVUlfVEVYVCA9IHtcbiAgRVJST1JfVU5FWFBFQ1RFRDogXCJVbmV4cGVjdGVkIGVycm9yXCIsXG4gIEVSUk9SX01JU1NJTkdfRlJBTUVTOiBcIk5vIGZyYW1lcyBmb3VuZC4gUGxlYXNlIGFkZCBzb21lIGZyYW1lcyB0byB0aGUgcGFnZS5cIixcbiAgV0FSTl9OT19UQVJHRVRTOiBcIlN0YW5kYXJkIGZyYW1lcyBub3QgZm91bmQuIFBsZWFzZSBzZWxlY3QgdGFyZ2V0IGZyYW1lcy5cIixcbiAgV0FSTl9UT09fTUFOWV9UQVJHRVRTOiBcIlBsZWFzZSBzZWxlY3QgdGhyZWUgdGFyZ2V0IGZyYW1lc1wiLFxuICBJTkZPX1BSRVZJRVc6IFwiUHJldmlldyBlYWNoIGZyYW1lIG91dHB1dFwiLFxuICBUSVRMRV9DSE9PU0VfRlJBTUU6IFwiQ2hvb3NlIHdoaWNoIGZyYW1lcyB0byBleHBvcnRcIixcbiAgVElUTEVfUFJFVklFVzogXCJQcmV2aWV3XCIsXG4gIFRJVExFX1JFU1BPTlNJVkVfUFJFVklFVzogXCJSZXNwb25zaXZlIHByZXZpZXdcIixcbiAgVElMRV9PVVRQVVQ6IFwiRXhwb3J0XCIsXG4gIEJVVFRPTl9ORVhUOiBcIk5leHRcIixcbiAgQlVUVE9OX0RPV05MT0FEOiBcIkRvd25sb2FkXCIsXG4gIEJVVFRPTl9QUkVWSU9VUzogXCJCYWNrXCIsXG59O1xuXG5leHBvcnQgY29uc3QgSU5JVElBTF9VSV9TSVpFID0ge1xuICB3aWR0aDogNDgwLFxuICBoZWlnaHQ6IDUwMCxcbiAgbWF4V2lkdGg6IDEyMDAsXG4gIG1heEhlaWdodDogOTAwLFxuICBtaW5XaWR0aDogNDIwLFxuICBtaW5IZWlnaHQ6IDQ4MCxcbn07XG5cbmV4cG9ydCBjb25zdCBGUkFNRV9XQVJOSU5HX1NJWkUgPSAzMDA7XG5cbmV4cG9ydCBlbnVtIEhFQURMSU5FX05PREVfTkFNRVMge1xuICBIRUFETElORSA9IFwiaGVhZGxpbmVcIixcbiAgU1VCSEVBRCA9IFwic3ViaGVhZFwiLFxuICBTT1VSQ0UgPSBcInNvdXJjZVwiLFxufVxuIiwgImltcG9ydCB7IE1TR19FVkVOVFMsIEhFQURMSU5FX05PREVfTkFNRVMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7XG4gIE1zZ0ZyYW1lc1R5cGUsXG4gIE1zZ05vRnJhbWVzVHlwZSxcbiAgTXNnUmVuZGVyVHlwZSxcbiAgTXNnRXJyb3JUeXBlLFxuICBNc2dDb21wcmVzc2VkSW1hZ2VUeXBlLFxuICB0ZXh0RGF0YSxcbiAgUG9zdE1zZyxcbiAgc2V0SGVhZGxpbmVzQW5kU291cmNlUHJvcHMsXG59IGZyb20gXCJ0eXBlc1wiO1xuXG4vLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gdGhlIFVJXG4vLyBOT1RFOiBMaXN0ZW4gZm9yIERPTV9SRUFEWSBtZXNzYWdlIHRvIGtpY2stb2ZmIG1haW4gZnVuY3Rpb25cbmZpZ21hLnVpLm9uKFwibWVzc2FnZVwiLCAoZSkgPT4gaGFuZGxlUmVjZWl2ZWRNc2coZSkpO1xuXG4vLyBSZW5kZXIgdGhlIERPTVxuLy8gTk9URTogb24gc3VjY2Vzc2Z1bCBVSSByZW5kZXIgYSBwb3N0IG1lc3NhZ2UgaXMgc2VuZCBiYWNrIG9mIERPTV9SRUFEWVxuZmlnbWEuc2hvd1VJKF9faHRtbF9fKTtcblxuLy8gUmVzaXplIFVJIHRvIG1heCB2aWV3cG9ydCBkaW1lbnNpb25zXG5jb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGZpZ21hLnZpZXdwb3J0LmJvdW5kcztcbmNvbnN0IHsgem9vbSB9ID0gZmlnbWEudmlld3BvcnQ7XG5jb25zdCBpbml0aWFsV2luZG93V2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogem9vbSk7XG5jb25zdCBpbml0aWFsV2luZG93SGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiB6b29tKTtcbmZpZ21hLnVpLnJlc2l6ZShpbml0aWFsV2luZG93V2lkdGgsIGluaXRpYWxXaW5kb3dIZWlnaHQpO1xuXG5jb25zdCBjb21wcmVzc2lvblBvb2w6IHtcbiAgdWlkOiBzdHJpbmc7XG4gIGNhbGxiYWNrOiAoaW1nOiBVaW50OEFycmF5KSA9PiB2b2lkO1xuICB0aW1lb3V0OiBudW1iZXI7XG59W10gPSBbXTtcblxuZnVuY3Rpb24gaGFuZGxlQ29tcHJlc3NlZE1zZyhtc2c6IE1zZ0NvbXByZXNzZWRJbWFnZVR5cGUpIHtcbiAgY29uc3QgeyB1aWQsIGltYWdlIH0gPSBtc2c7XG5cbiAgY29uc3QgcG9vbEl0ZW1JbmRleCA9IGNvbXByZXNzaW9uUG9vbC5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0udWlkID09PSB1aWQpO1xuICBpZiAocG9vbEl0ZW1JbmRleCA+IC0xKSB7XG4gICAgY29tcHJlc3Npb25Qb29sW3Bvb2xJdGVtSW5kZXhdLmNhbGxiYWNrKGltYWdlKTtcbiAgICBjbGVhclRpbWVvdXQoY29tcHJlc3Npb25Qb29sW3Bvb2xJdGVtSW5kZXhdLnRpbWVvdXQpO1xuICAgIGNvbXByZXNzaW9uUG9vbC5zcGxpY2UocG9vbEl0ZW1JbmRleCwgMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEZyYW1lcygpIHtcbiAgY29uc3QgeyBjdXJyZW50UGFnZSB9ID0gZmlnbWE7XG4gIGNvbnN0IHJvb3RGcmFtZXMgPSBjdXJyZW50UGFnZS5jaGlsZHJlbi5maWx0ZXIoXG4gICAgKG5vZGUpID0+IG5vZGUudHlwZSA9PT0gXCJGUkFNRVwiXG4gICkgYXMgRnJhbWVOb2RlW107XG5cbiAgLy8gUmV0dXJuIGVycm9yIGlmIHRoZXJlJ3Mgbm8gZnJhbWVzIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgaWYgKHJvb3RGcmFtZXMubGVuZ3RoIDwgMSkge1xuICAgIGNvbnNvbGUud2FybihcIk5vIGZyYW1lc1wiKTtcbiAgICBmaWdtYS51aS5wb3N0TWVzc2FnZSh7IHR5cGU6IE1TR19FVkVOVFMuTk9fRlJBTUVTIH0gYXMgTXNnTm9GcmFtZXNUeXBlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBoZWFkbGluZXNBbmRTb3VyY2UgPSBnZXRIZWFkbGluZXNBbmRTb3VyY2UoY3VycmVudFBhZ2UpO1xuXG4gIGNvbnN0IGZyYW1lc0RhdGEgPSByb290RnJhbWVzLm1hcCgoZnJhbWUpID0+IHtcbiAgICBjb25zdCB7IG5hbWUsIHdpZHRoLCBoZWlnaHQsIGlkIH0gPSBmcmFtZTtcbiAgICBjb25zdCB0ZXh0Tm9kZXMgPSBnZXRUZXh0Tm9kZXMoZnJhbWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGlkLFxuICAgICAgdGV4dE5vZGVzLFxuICAgICAgcmVzcG9uc2l2ZTogZmFsc2UsXG4gICAgICBzZWxlY3RlZDogdHJ1ZSxcbiAgICB9O1xuICB9KTtcblxuICBmaWdtYS51aS5wb3N0TWVzc2FnZSh7XG4gICAgdHlwZTogTVNHX0VWRU5UUy5GT1VORF9GUkFNRVMsXG4gICAgZnJhbWVzOiBmcmFtZXNEYXRhLFxuICAgIHdpbmRvd1dpZHRoOiBpbml0aWFsV2luZG93V2lkdGgsXG4gICAgd2luZG93SGVpZ2h0OiBpbml0aWFsV2luZG93SGVpZ2h0LFxuICAgIC4uLmhlYWRsaW5lc0FuZFNvdXJjZSxcbiAgfSBhcyBNc2dGcmFtZXNUeXBlKTtcbn1cblxuLy8gVE9ETzogQnJlYWsgb3V0IG5lc3RlZCBhc3luYyBsb2dpY1xuZnVuY3Rpb24gY29tcHJlc3NJbWFnZShub2RlOiBEZWZhdWx0U2hhcGVNaXhpbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBuZXdGaWxsczogYW55W10gPSBbXTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZmlsbHMgPSBub2RlLmZpbGxzID09PSBmaWdtYS5taXhlZCA/IFtdIDogWy4uLm5vZGUuZmlsbHNdO1xuXG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICBmaWxscy5tYXAoYXN5bmMgKHBhaW50KSA9PiB7XG4gICAgICAgIGlmIChwYWludC50eXBlID09PSBcIklNQUdFXCIgJiYgcGFpbnQuaW1hZ2VIYXNoKSB7XG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSBmaWdtYS5nZXRJbWFnZUJ5SGFzaChwYWludC5pbWFnZUhhc2gpO1xuICAgICAgICAgIGNvbnN0IGltYWdlQnl0ZXMgPSBhd2FpdCBpbWFnZS5nZXRCeXRlc0FzeW5jKCk7XG4gICAgICAgICAgY29uc3QgdWlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzMik7XG5cbiAgICAgICAgICAvLyBTZW5kIHBvc3QgbWVzc2FnZVxuICAgICAgICAgIGZpZ21hLnVpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IE1TR19FVkVOVFMuQ09NUFJFU1NfSU1BR0UsXG4gICAgICAgICAgICBpbWFnZTogaW1hZ2VCeXRlcyxcbiAgICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCxcbiAgICAgICAgICAgIHVpZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgX3JlamVjdChcIkNvbXByZXNzIGltYWdlIHJlc3BvbnNlIHRpbWVkIG91dC5cIik7XG4gICAgICAgICAgICB9LCA1MDAwKTtcblxuICAgICAgICAgICAgY29tcHJlc3Npb25Qb29sLnB1c2goe1xuICAgICAgICAgICAgICB1aWQsXG5cbiAgICAgICAgICAgICAgY2FsbGJhY2s6IChpbWFnZTogVWludDhBcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhaW50ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYWludCkpO1xuICAgICAgICAgICAgICAgIG5ld1BhaW50LmltYWdlSGFzaCA9IGZpZ21hLmNyZWF0ZUltYWdlKGltYWdlKS5oYXNoO1xuICAgICAgICAgICAgICAgIG5ld0ZpbGxzLnB1c2gobmV3UGFpbnQpO1xuICAgICAgICAgICAgICAgIHJlcygpO1xuICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApLnRoZW4oKCkgPT4ge1xuICAgICAgbm9kZS5maWxscyA9IG5ld0ZpbGxzO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVuZGVyKGZyYW1lSWQ6IHN0cmluZykge1xuICBsZXQgY2xvbmU7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBmcmFtZSA9IGZpZ21hLmdldE5vZGVCeUlkKGZyYW1lSWQpO1xuICAgIGlmICghZnJhbWUgfHwgZnJhbWUudHlwZSAhPT0gXCJGUkFNRVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGZyYW1lXCIpO1xuICAgIH1cblxuICAgIGNsb25lID0gZnJhbWUuY2xvbmUoKTtcbiAgICBjbG9uZS5uYW1lID0gYFt0ZW1wXSAke2ZyYW1lLm5hbWV9YDtcblxuICAgIGNvbnN0IGNsb25lVGV4dE5vZGVzID0gY2xvbmUuZmluZENoaWxkcmVuKChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiVEVYVFwiKTtcbiAgICBjbG9uZVRleHROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiBub2RlLnJlbW92ZSgpKTtcblxuICAgIGNvbnN0IG5vZGVzV2l0aFBhaW50SW1hZ2VzID0gY2xvbmUuZmluZENoaWxkcmVuKChub2RlKSA9PiB7XG4gICAgICBpZiAoXCJmaWxsc1wiIGluIG5vZGUgJiYgbm9kZS5maWxscyAhPT0gZmlnbWEubWl4ZWQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZmlsbHMuc29tZSgoZmlsbCkgPT4gXCJpbWFnZUhhc2hcIiBpbiBmaWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KSBhcyBEZWZhdWx0U2hhcGVNaXhpbltdO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobm9kZXNXaXRoUGFpbnRJbWFnZXMubWFwKGNvbXByZXNzSW1hZ2UpKTtcblxuICAgIC8vIFdhaXQgZm9yIEZpZ21hIHRvIHByb2Nlc3MgaW1hZ2UgaGFzaCBvdGhlcndpc2UgdGhlIHBhaW50IGZpbGwgd2l0aCBoYXZlXG4gICAgLy8gYW4gaW5jb3JyZWN0IHRyYW5zZm9ybSBzY2FsZVxuICAgIC8vIFRPRE86IEZpbmQgYmV0dGVyIHdheVxuICAgIGlmIChub2Rlc1dpdGhQYWludEltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coXCJSRU5ERVJJTkcgU1ZHXCIpO1xuICAgIGNvbnN0IHN2ZyA9IGF3YWl0IGNsb25lLmV4cG9ydEFzeW5jKHtcbiAgICAgIGZvcm1hdDogXCJTVkdcIixcbiAgICAgIHN2Z091dGxpbmVUZXh0OiBmYWxzZSxcbiAgICAgIHN2Z1NpbXBsaWZ5U3Ryb2tlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgZmlnbWEudWkucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogTVNHX0VWRU5UUy5SRU5ERVIsXG4gICAgICBmcmFtZUlkLFxuICAgICAgc3ZnLFxuICAgIH0gYXMgTXNnUmVuZGVyVHlwZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGZpZ21hLnVpLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IE1TR19FVkVOVFMuRVJST1IsXG4gICAgICBlcnJvclRleHQ6IGBSZW5kZXIgZmFpbGVkOiAke2Vycj8ubWVzc2FnZX1gLFxuICAgIH0gYXMgTXNnRXJyb3JUeXBlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLndhcm4oXCJJbnNpZGUgcmVuZGVyIGZpbmFsbGF5XCIpO1xuICAgIC8vIFJlbW92aW5nIGNsb25lXG4gICAgY2xvbmU/LnJlbW92ZSgpO1xuICB9XG59XG5cbi8vIEV4dHJhY3Qgb2JqZWN0IHByb3BlcnRpZXMgZnJvbSB0ZXh0Tm9kZSBmb3IgcGFzc2luZyB2aWEgcG9zdE1lc3NhZ2VcbmZ1bmN0aW9uIGdldFRleHROb2RlcyhmcmFtZTogRnJhbWVOb2RlKTogdGV4dERhdGFbXSB7XG4gIGNvbnN0IHRleHROb2RlcyA9IGZyYW1lLmZpbmRBbGwoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBcIlRFWFRcIikgYXMgVGV4dE5vZGVbXTtcbiAgY29uc3QgeyBhYnNvbHV0ZVRyYW5zZm9ybSB9ID0gZnJhbWU7XG4gIGNvbnN0IHJvb3RYID0gYWJzb2x1dGVUcmFuc2Zvcm1bMF1bMl07XG4gIGNvbnN0IHJvb3RZID0gYWJzb2x1dGVUcmFuc2Zvcm1bMV1bMl07XG5cbiAgcmV0dXJuIHRleHROb2Rlcy5tYXAoXG4gICAgKG5vZGUpOiB0ZXh0RGF0YSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFic29sdXRlVHJhbnNmb3JtLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBmb250U2l6ZTogZm9udFNpemVEYXRhLFxuICAgICAgICBmb250TmFtZSxcbiAgICAgICAgZmlsbHMsXG4gICAgICAgIGNoYXJhY3RlcnMsXG4gICAgICAgIGxpbmVIZWlnaHQsXG4gICAgICAgIGxldHRlclNwYWNpbmcsXG4gICAgICAgIHRleHRBbGlnbkhvcml6b250YWwsXG4gICAgICAgIHRleHRBbGlnblZlcnRpY2FsLFxuICAgICAgfSA9IG5vZGU7XG5cbiAgICAgIC8vIE5PVEU6IEZpZ21hIG5vZGUgeCwgeSBhcmUgcmVsYXRpdmUgdG8gZmlyc3QgcGFyZW50LCB3ZSB3YW50IHRoZW1cbiAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSByb290IGZyYW1lXG4gICAgICBjb25zdCB0ZXh0WCA9IGFic29sdXRlVHJhbnNmb3JtWzBdWzJdO1xuICAgICAgY29uc3QgdGV4dFkgPSBhYnNvbHV0ZVRyYW5zZm9ybVsxXVsyXTtcbiAgICAgIGNvbnN0IHggPSB0ZXh0WCAtIHJvb3RYO1xuICAgICAgY29uc3QgeSA9IHRleHRZIC0gcm9vdFk7XG5cbiAgICAgIC8vIEV4dHJhY3QgYmFzaWMgZmlsbCBjb2xvdXJcbiAgICAgIGNvbnN0IFtmaWxsXSA9IGZpbGxzID09PSBmaWdtYS5taXhlZCA/IFtdIDogZmlsbHM7XG4gICAgICBsZXQgY29sb3VyID0geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAxIH07XG4gICAgICBpZiAoZmlsbC50eXBlID09PSBcIlNPTElEXCIpIHtcbiAgICAgICAgY29sb3VyID0geyAuLi5jb2xvdXIsIGE6IGZpbGwub3BhY2l0eSB8fCAxIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgZm9udCBmYW1pbHlcbiAgICAgIGxldCBmb250U2l6ZSA9IDE2O1xuICAgICAgaWYgKGZvbnRTaXplRGF0YSAhPT0gZmlnbWEubWl4ZWQpIHtcbiAgICAgICAgZm9udFNpemUgPSBmb250U2l6ZURhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4dHJhY3QgZm9udCBmYW1pbHlcbiAgICAgIC8vIFRPRE86IENvbmZpcm0gZmFsbGJhY2sgZm9udHNcbiAgICAgIGxldCBmb250RmFtaWx5ID0gXCJBcmlhbFwiO1xuICAgICAgbGV0IGZvbnRTdHlsZSA9IFwiUmVndWxhclwiO1xuICAgICAgaWYgKGZvbnROYW1lICE9PSBmaWdtYS5taXhlZCkge1xuICAgICAgICBmb250RmFtaWx5ID0gZm9udE5hbWUuZmFtaWx5O1xuICAgICAgICBmb250U3R5bGUgPSBmb250TmFtZS5zdHlsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTdHlsZSxcbiAgICAgICAgY29sb3VyLFxuICAgICAgICBjaGFyYWN0ZXJzLFxuICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICBsZXR0ZXJTcGFjaW5nLFxuICAgICAgICB0ZXh0QWxpZ25Ib3Jpem9udGFsLFxuICAgICAgICB0ZXh0QWxpZ25WZXJ0aWNhbCxcbiAgICAgIH07XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkbGluZXNBbmRTb3VyY2UocGFnZU5vZGU6IFBhZ2VOb2RlKSB7XG4gIGNvbnN0IE5PREVfTkFNRVMgPSBbXCJoZWFkbGluZVwiLCBcInN1YmhlYWRcIiwgXCJzb3VyY2VcIl07XG5cbiAgY29uc3QgcmVzdWx0OiB7IFtpZDogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIE5PREVfTkFNRVMpIHtcbiAgICBjb25zdCBub2RlID0gcGFnZU5vZGUuZmluZENoaWxkKFxuICAgICAgKG5vZGUpID0+IG5vZGUubmFtZSA9PT0gbmFtZSAmJiBub2RlLnR5cGUgPT09IFwiVEVYVFwiXG4gICAgKSBhcyBUZXh0Tm9kZSB8IG51bGw7XG5cbiAgICByZXN1bHRbbmFtZV0gPSBub2RlPy5jaGFyYWN0ZXJzO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2V0SGVhZGxpbmVzQW5kU291cmNlKHByb3BzOiBzZXRIZWFkbGluZXNBbmRTb3VyY2VQcm9wcykge1xuICBjb25zdCB7IHBhZ2VOb2RlIH0gPSBwcm9wcztcbiAgY29uc3QgZnJhbWVzID0gcGFnZU5vZGUuZmluZENoaWxkcmVuKChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiRlJBTUVcIik7XG4gIGNvbnN0IG1vc3RMZWZ0UG9zID0gTWF0aC5taW4oLi4uZnJhbWVzLm1hcCgobm9kZSkgPT4gbm9kZS54KSk7XG4gIGNvbnN0IG1vc3RUb3BQb3MgPSBNYXRoLm1pbiguLi5mcmFtZXMubWFwKChub2RlKSA9PiBub2RlLnkpKTtcblxuICBPYmplY3QudmFsdWVzKEhFQURMSU5FX05PREVfTkFNRVMpLmZvckVhY2goYXN5bmMgKG5hbWUsIF9pKSA9PiB7XG4gICAgbGV0IG5vZGUgPSBwYWdlTm9kZS5maW5kQ2hpbGQoXG4gICAgICAobm9kZSkgPT4gbm9kZS5uYW1lID09PSBuYW1lICYmIG5vZGUudHlwZSA9PT0gXCJURVhUXCJcbiAgICApIGFzIFRleHROb2RlIHwgbnVsbDtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHByb3BzW25hbWVdO1xuXG4gICAgLy8gUmVtb3ZlIG5vZGUgaWYgdGhlcmUncyBubyB0ZXh0IGNvbnRlbnRcbiAgICBpZiAoIXRleHRDb250ZW50KSB7XG4gICAgICBpZiAobm9kZSkgbm9kZS5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBub2RlID0gZmlnbWEuY3JlYXRlVGV4dCgpO1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcblxuICAgICAgbGV0IHkgPSBtb3N0VG9wUG9zIC0gNjA7XG4gICAgICBpZiAobmFtZSA9PT0gSEVBRExJTkVfTk9ERV9OQU1FUy5IRUFETElORSkge1xuICAgICAgICB5IC09IDYwO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBIRUFETElORV9OT0RFX05BTUVTLlNVQkhFQUQpIHtcbiAgICAgICAgeSAtPSAzMDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5yZWxhdGl2ZVRyYW5zZm9ybSA9IFtcbiAgICAgICAgWzEsIDAsIG1vc3RMZWZ0UG9zXSxcbiAgICAgICAgWzAsIDEsIHldLFxuICAgICAgXTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGV4dCBub2RlIGlzIGxvY2tlZFxuICAgIG5vZGUubG9ja2VkID0gdHJ1ZTtcblxuICAgIC8vIExvYWQgZm9udFxuICAgIGNvbnN0IGZvbnROYW1lID1cbiAgICAgIG5vZGUuZm9udE5hbWUgIT09IGZpZ21hLm1peGVkID8gbm9kZS5mb250TmFtZS5mYW1pbHkgOiBcIlJvYm90b1wiO1xuICAgIGNvbnN0IGZvbnRTdHlsZSA9XG4gICAgICBub2RlLmZvbnROYW1lICE9PSBmaWdtYS5taXhlZCA/IG5vZGUuZm9udE5hbWUuc3R5bGUgOiBcIlJlZ3VsYXJcIjtcbiAgICBhd2FpdCBmaWdtYS5sb2FkRm9udEFzeW5jKHsgZmFtaWx5OiBmb250TmFtZSwgc3R5bGU6IGZvbnRTdHlsZSB9KTtcblxuICAgIC8vIFNldCB0ZXh0IG5vZGUgY29udGVudFxuICAgIG5vZGUuY2hhcmFjdGVycyA9IHByb3BzW25hbWVdIHx8IFwiXCI7XG4gIH0pO1xufVxuXG4vLyBIYW5kbGUgbWVzc2FnZXMgZnJvbSB0aGUgVUlcbmZ1bmN0aW9uIGhhbmRsZVJlY2VpdmVkTXNnKG1zZzogUG9zdE1zZykge1xuICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgY2FzZSBNU0dfRVZFTlRTLkVSUk9SOlxuICAgICAgY29uc29sZS5sb2coXCJwbHVnaW4gbXNnOiBlcnJvclwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBNU0dfRVZFTlRTLkNMT1NFOlxuICAgICAgY29uc29sZS5sb2coXCJwbHVnaW4gbXNnOiBjbG9zZVwiKTtcbiAgICAgIGZpZ21hLmNsb3NlUGx1Z2luKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTVNHX0VWRU5UUy5ET01fUkVBRFk6XG4gICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IERPTSBSRUFEWVwiKTtcbiAgICAgIGdldFJvb3RGcmFtZXMoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBNU0dfRVZFTlRTLlJFTkRFUjpcbiAgICAgIGNvbnNvbGUubG9nKFwicGx1Z2luIG1zZzogcmVuZGVyXCIsIG1zZy5mcmFtZUlkKTtcbiAgICAgIGhhbmRsZVJlbmRlcihtc2cuZnJhbWVJZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTVNHX0VWRU5UUy5SRVNJWkU6XG4gICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IHJlc2l6ZVwiKTtcbiAgICAgIGZpZ21hLnVpLnJlc2l6ZShtc2cud2lkdGgsIG1zZy5oZWlnaHQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuVVBEQVRFX0hFQURMSU5FUzpcbiAgICAgIHNldEhlYWRsaW5lc0FuZFNvdXJjZSh7XG4gICAgICAgIHBhZ2VOb2RlOiBmaWdtYS5jdXJyZW50UGFnZSxcbiAgICAgICAgaGVhZGxpbmU6IG1zZy5oZWFkbGluZSxcbiAgICAgICAgc3ViaGVhZDogbXNnLnN1YmhlYWQsXG4gICAgICAgIHNvdXJjZTogbXNnLnNvdXJjZSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuQ09NUFJFU1NFRF9JTUFHRTpcbiAgICAgIGhhbmRsZUNvbXByZXNzZWRNc2cobXNnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIHBvc3QgbWVzc2FnZVwiLCBtc2cpO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7O0FBQUEsQUFBTyxNQUFLO0FBQUwsWUFBSztBQUNWO0FBQ0E7QUFDQTtBQUNB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
