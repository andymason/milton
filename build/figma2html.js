(() => {
  let __assign = Object.assign;

  // src/constants.ts
  var STAGES;
  (function(STAGES2) {
    STAGES2[STAGES2["CHOOSE_FRAMES"] = 0] = "CHOOSE_FRAMES";
    STAGES2[STAGES2["PREVIEW_OUTPUT"] = 1] = "PREVIEW_OUTPUT";
    STAGES2[STAGES2["RESPONSIVE_PREVIEW"] = 2] = "RESPONSIVE_PREVIEW";
    STAGES2[STAGES2["SAVE_OUTPUT"] = 3] = "SAVE_OUTPUT";
  })(STAGES || (STAGES = {}));
  var MSG_EVENTS;
  (function(MSG_EVENTS2) {
    MSG_EVENTS2[MSG_EVENTS2["DOM_READY"] = 0] = "DOM_READY";
    MSG_EVENTS2[MSG_EVENTS2["NO_FRAMES"] = 1] = "NO_FRAMES";
    MSG_EVENTS2[MSG_EVENTS2["FOUND_FRAMES"] = 2] = "FOUND_FRAMES";
    MSG_EVENTS2[MSG_EVENTS2["RESIZE"] = 3] = "RESIZE";
    MSG_EVENTS2[MSG_EVENTS2["RENDER"] = 4] = "RENDER";
    MSG_EVENTS2[MSG_EVENTS2["CLOSE"] = 5] = "CLOSE";
    MSG_EVENTS2[MSG_EVENTS2["ERROR"] = 6] = "ERROR";
    MSG_EVENTS2[MSG_EVENTS2["UPDATE_HEADLINES"] = 7] = "UPDATE_HEADLINES";
    MSG_EVENTS2[MSG_EVENTS2["COMPRESS_IMAGE"] = 8] = "COMPRESS_IMAGE";
    MSG_EVENTS2[MSG_EVENTS2["COMPRESSED_IMAGE"] = 9] = "COMPRESSED_IMAGE";
  })(MSG_EVENTS || (MSG_EVENTS = {}));
  var OUTPUT_FORMATS;
  (function(OUTPUT_FORMATS2) {
    OUTPUT_FORMATS2[OUTPUT_FORMATS2["INLINE"] = 0] = "INLINE";
    OUTPUT_FORMATS2[OUTPUT_FORMATS2["IFRAME"] = 1] = "IFRAME";
  })(OUTPUT_FORMATS || (OUTPUT_FORMATS = {}));
  var HEADLINE_NODE_NAMES;
  (function(HEADLINE_NODE_NAMES2) {
    HEADLINE_NODE_NAMES2["HEADLINE"] = "headline";
    HEADLINE_NODE_NAMES2["SUBHEAD"] = "subhead";
    HEADLINE_NODE_NAMES2["SOURCE"] = "source";
  })(HEADLINE_NODE_NAMES || (HEADLINE_NODE_NAMES = {}));

  // src/index.tsx
  figma.ui.on("message", (e) => handleReceivedMsg(e));
  figma.showUI(__html__);
  const {width, height} = figma.viewport.bounds;
  const {zoom} = figma.viewport;
  const initialWindowWidth = Math.round(width * zoom);
  const initialWindowHeight = Math.round(height * zoom);
  figma.ui.resize(initialWindowWidth, initialWindowHeight);
  const compressionPool = [];
  function handleCompressedMsg(msg) {
    const {uid, image} = msg;
    const poolItemIndex = compressionPool.findIndex((item) => item.uid === uid);
    if (poolItemIndex > -1) {
      compressionPool[poolItemIndex].callback(image);
      clearTimeout(compressionPool[poolItemIndex].timeout);
      compressionPool.splice(poolItemIndex, 1);
    }
  }
  function getRootFrames() {
    const {currentPage} = figma;
    const rootFrames = currentPage.children.filter((node) => node.type === "FRAME");
    if (rootFrames.length < 1) {
      console.warn("No frames");
      figma.ui.postMessage({type: MSG_EVENTS.NO_FRAMES});
      return;
    }
    const headlinesAndSource = getHeadlinesAndSource(currentPage);
    const framesData = rootFrames.map((frame) => {
      const {name, width: width2, height: height2, id} = frame;
      const textNodes = getTextNodes(frame);
      return {
        name,
        width: width2,
        height: height2,
        id,
        textNodes,
        responsive: false,
        selected: true
      };
    });
    figma.ui.postMessage(__assign({
      type: MSG_EVENTS.FOUND_FRAMES,
      frames: framesData,
      windowWidth: initialWindowWidth,
      windowHeight: initialWindowHeight
    }, headlinesAndSource));
  }
  function getTextNodes(frame) {
    const textNodes = frame.findAll(({type}) => type === "TEXT");
    const {absoluteTransform} = frame;
    const rootX = absoluteTransform[0][2];
    const rootY = absoluteTransform[1][2];
    return textNodes.map((node) => {
      const {
        absoluteTransform: absoluteTransform2,
        width: width2,
        height: height2,
        fontSize: fontSizeData,
        fontName,
        fills,
        characters,
        lineHeight,
        letterSpacing,
        textAlignHorizontal,
        textAlignVertical
      } = node;
      const textX = absoluteTransform2[0][2];
      const textY = absoluteTransform2[1][2];
      const x = textX - rootX;
      const y = textY - rootY;
      const [fill] = fills === figma.mixed ? [] : fills;
      let colour = {r: 0, g: 0, b: 0, a: 1};
      if (fill.type === "SOLID") {
        colour = __assign(__assign({}, colour), {a: fill.opacity || 1});
      }
      const fontSize = fontSizeData !== figma.mixed ? fontSizeData : 16;
      const fontFamily = fontName !== figma.mixed ? fontName.family : "Arial";
      const fontStyle = fontName !== figma.mixed ? fontName.style : "Regular";
      return {
        x,
        y,
        width: width2,
        height: height2,
        fontSize,
        fontFamily,
        fontStyle,
        colour,
        characters,
        lineHeight,
        letterSpacing,
        textAlignHorizontal,
        textAlignVertical
      };
    });
  }
  function getHeadlinesAndSource(pageNode) {
    const NODE_NAMES = ["headline", "subhead", "source"];
    const result = {};
    for (const name of NODE_NAMES) {
      const node = pageNode.findChild((node2) => node2.name === name && node2.type === "TEXT");
      result[name] = node == null ? void 0 : node.characters;
    }
    return result;
  }
  function setHeadlinesAndSource(props) {
    const {pageNode} = props;
    const frames = pageNode.findChildren((node) => node.type === "FRAME");
    const mostLeftPos = Math.min(...frames.map((node) => node.x));
    const mostTopPos = Math.min(...frames.map((node) => node.y));
    for (const name of Object.values(HEADLINE_NODE_NAMES)) {
      let node = pageNode.findChild((node2) => node2.name === name && node2.type === "TEXT") || null;
      const textContent = props[name];
      if (node && !textContent) {
        node.remove();
        return;
      }
      if (!textContent) {
        return;
      }
      if (!node) {
        node = figma.createText();
        node.name = name;
        let y = mostTopPos - 60;
        if (name === HEADLINE_NODE_NAMES.HEADLINE) {
          y -= 60;
        } else if (name === HEADLINE_NODE_NAMES.SUBHEAD) {
          y -= 30;
        }
        node.relativeTransform = [
          [1, 0, mostLeftPos],
          [0, 1, y]
        ];
      }
      node.locked = true;
      const fontName = node.fontName !== figma.mixed ? node.fontName.family : "Roboto";
      const fontStyle = node.fontName !== figma.mixed ? node.fontName.style : "Regular";
      figma.loadFontAsync({family: fontName, style: fontStyle}).then(() => {
        node.characters = props[name] || "";
      }).catch((err) => {
        console.error("Failed to load font", err);
      });
    }
  }
  function handleReceivedMsg(msg) {
    switch (msg.type) {
      case MSG_EVENTS.ERROR:
        console.log("plugin msg: error");
        break;
      case MSG_EVENTS.CLOSE:
        console.log("plugin msg: close");
        figma.closePlugin();
        break;
      case MSG_EVENTS.DOM_READY:
        console.log("plugin msg: DOM READY");
        getRootFrames();
        break;
      case MSG_EVENTS.RENDER: {
        try {
          console.log("plugin msg: render", msg.frameId);
          console.log(msg.ids);
          const {ids} = msg;
          const outputNode = figma.createFrame();
          outputNode.name = "output";
          const frames = figma.currentPage.children.filter(({id}) => ids.includes(id));
          console.log(frames);
          const maxWidth = Math.max(...frames.map((f) => f.width));
          const maxHeight = Math.max(...frames.map((f) => f.height));
          outputNode.resizeWithoutConstraints(maxWidth, maxHeight);
          for (const frame of frames) {
            const clone = frame == null ? void 0 : frame.clone();
            outputNode.appendChild(clone);
            clone.x = 0;
            clone.y = 0;
            clone.name = frame.id;
            console.log(frame.id);
          }
          outputNode.exportAsync({
            format: "SVG",
            svgSimplifyStroke: true,
            svgOutlineText: false,
            svgIdAttribute: true
          }).then((svgData) => {
            figma.ui.postMessage({
              type: MSG_EVENTS.RENDER,
              svgData
            });
            outputNode == null ? void 0 : outputNode.remove();
          }).catch((err) => {
            console.error(err);
            outputNode == null ? void 0 : outputNode.remove();
          });
        } catch (err) {
          console.error(err);
        }
        break;
      }
      case MSG_EVENTS.RESIZE:
        console.log("plugin msg: resize");
        figma.ui.resize(msg.width, msg.height);
        break;
      case MSG_EVENTS.UPDATE_HEADLINES:
        setHeadlinesAndSource({
          pageNode: figma.currentPage,
          headline: msg.headline,
          subhead: msg.subhead,
          source: msg.source
        });
        break;
      case MSG_EVENTS.COMPRESSED_IMAGE:
        handleCompressedMsg(msg);
        break;
      default:
        console.error("Unknown post message", msg);
    }
  }
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL2NvbnN0YW50cy50cyIsICJzcmMvaW5kZXgudHN4Il0sCiAgInNvdXJjZXNDb250ZW50IjogWyJleHBvcnQgZW51bSBTVEFHRVMge1xuICBDSE9PU0VfRlJBTUVTLFxuICBQUkVWSUVXX09VVFBVVCxcbiAgUkVTUE9OU0lWRV9QUkVWSUVXLFxuICBTQVZFX09VVFBVVCxcbn1cblxuZXhwb3J0IGVudW0gTVNHX0VWRU5UUyB7XG4gIERPTV9SRUFEWSxcbiAgTk9fRlJBTUVTLFxuICBGT1VORF9GUkFNRVMsXG4gIFJFU0laRSxcbiAgUkVOREVSLFxuICBDTE9TRSxcbiAgRVJST1IsXG4gIFVQREFURV9IRUFETElORVMsXG4gIENPTVBSRVNTX0lNQUdFLFxuICBDT01QUkVTU0VEX0lNQUdFLFxufVxuXG5leHBvcnQgZW51bSBPVVRQVVRfRk9STUFUUyB7XG4gIElOTElORSxcbiAgSUZSQU1FLFxufVxuXG5leHBvcnQgY29uc3QgVUlfVEVYVCA9IHtcbiAgRVJST1JfVU5FWFBFQ1RFRDogXCJVbmV4cGVjdGVkIGVycm9yXCIsXG4gIEVSUk9SX01JU1NJTkdfRlJBTUVTOiBcIk5vIGZyYW1lcyBmb3VuZC4gUGxlYXNlIGFkZCBzb21lIGZyYW1lcyB0byB0aGUgcGFnZS5cIixcbiAgV0FSTl9OT19UQVJHRVRTOiBcIlN0YW5kYXJkIGZyYW1lcyBub3QgZm91bmQuIFBsZWFzZSBzZWxlY3QgdGFyZ2V0IGZyYW1lcy5cIixcbiAgV0FSTl9UT09fTUFOWV9UQVJHRVRTOiBcIlBsZWFzZSBzZWxlY3QgdGhyZWUgdGFyZ2V0IGZyYW1lc1wiLFxuICBJTkZPX1BSRVZJRVc6IFwiUHJldmlldyBlYWNoIGZyYW1lIG91dHB1dFwiLFxuICBUSVRMRV9DSE9PU0VfRlJBTUU6IFwiQ2hvb3NlIHdoaWNoIGZyYW1lcyB0byBleHBvcnRcIixcbiAgVElUTEVfUFJFVklFVzogXCJQcmV2aWV3XCIsXG4gIFRJVExFX1JFU1BPTlNJVkVfUFJFVklFVzogXCJSZXNwb25zaXZlIHByZXZpZXdcIixcbiAgVElMRV9PVVRQVVQ6IFwiRXhwb3J0XCIsXG4gIEJVVFRPTl9ORVhUOiBcIk5leHRcIixcbiAgQlVUVE9OX0RPV05MT0FEOiBcIkRvd25sb2FkXCIsXG4gIEJVVFRPTl9QUkVWSU9VUzogXCJCYWNrXCIsXG59O1xuXG5leHBvcnQgY29uc3QgSU5JVElBTF9VSV9TSVpFID0ge1xuICB3aWR0aDogNDgwLFxuICBoZWlnaHQ6IDUwMCxcbiAgbWF4V2lkdGg6IDEyMDAsXG4gIG1heEhlaWdodDogOTAwLFxuICBtaW5XaWR0aDogNDIwLFxuICBtaW5IZWlnaHQ6IDQ4MCxcbn07XG5cbmV4cG9ydCBjb25zdCBGUkFNRV9XQVJOSU5HX1NJWkUgPSAzMDA7XG5cbmV4cG9ydCBlbnVtIEhFQURMSU5FX05PREVfTkFNRVMge1xuICBIRUFETElORSA9IFwiaGVhZGxpbmVcIixcbiAgU1VCSEVBRCA9IFwic3ViaGVhZFwiLFxuICBTT1VSQ0UgPSBcInNvdXJjZVwiLFxufVxuIiwgImltcG9ydCB7IE1TR19FVkVOVFMsIEhFQURMSU5FX05PREVfTkFNRVMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7XG4gIE1zZ05vRnJhbWVzVHlwZSxcbiAgTXNnUmVuZGVyVHlwZSxcbiAgTXNnRXJyb3JUeXBlLFxuICBNc2dDb21wcmVzc2VkSW1hZ2VUeXBlLFxuICB0ZXh0RGF0YSxcbiAgUG9zdE1zZyxcbiAgc2V0SGVhZGxpbmVzQW5kU291cmNlUHJvcHMsXG59IGZyb20gXCJ0eXBlc1wiO1xuXG4vLyBMaXN0ZW4gZm9yIG1lc3NhZ2VzIGZyb20gdGhlIFVJXG4vLyBOT1RFOiBMaXN0ZW4gZm9yIERPTV9SRUFEWSBtZXNzYWdlIHRvIGtpY2stb2ZmIG1haW4gZnVuY3Rpb25cbmZpZ21hLnVpLm9uKFwibWVzc2FnZVwiLCAoZSkgPT4gaGFuZGxlUmVjZWl2ZWRNc2coZSkpO1xuXG4vLyBSZW5kZXIgdGhlIERPTVxuLy8gTk9URTogb24gc3VjY2Vzc2Z1bCBVSSByZW5kZXIgYSBwb3N0IG1lc3NhZ2UgaXMgc2VuZCBiYWNrIG9mIERPTV9SRUFEWVxuZmlnbWEuc2hvd1VJKF9faHRtbF9fKTtcblxuLy8gUmVzaXplIFVJIHRvIG1heCB2aWV3cG9ydCBkaW1lbnNpb25zXG5jb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGZpZ21hLnZpZXdwb3J0LmJvdW5kcztcbmNvbnN0IHsgem9vbSB9ID0gZmlnbWEudmlld3BvcnQ7XG5jb25zdCBpbml0aWFsV2luZG93V2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogem9vbSk7XG5jb25zdCBpbml0aWFsV2luZG93SGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiB6b29tKTtcbmZpZ21hLnVpLnJlc2l6ZShpbml0aWFsV2luZG93V2lkdGgsIGluaXRpYWxXaW5kb3dIZWlnaHQpO1xuXG4vLyBUT0RPOiBBc3luYyBpbWFnZSBjb21wcmVzc2lvbiB1c2luZyBjYWxsYmFjayBhcnJheSBmZWVscyBoYWNreS5cbi8vIFRha2UgYW5vdGhlciBsb29rLlxuY29uc3QgY29tcHJlc3Npb25Qb29sOiB7XG4gIHVpZDogc3RyaW5nO1xuICBjYWxsYmFjazogKGltZzogVWludDhBcnJheSkgPT4gdm9pZDtcbiAgdGltZW91dDogbnVtYmVyO1xufVtdID0gW107XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbXByZXNzZWRNc2cobXNnOiBNc2dDb21wcmVzc2VkSW1hZ2VUeXBlKSB7XG4gIGNvbnN0IHsgdWlkLCBpbWFnZSB9ID0gbXNnO1xuXG4gIGNvbnN0IHBvb2xJdGVtSW5kZXggPSBjb21wcmVzc2lvblBvb2wuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtLnVpZCA9PT0gdWlkKTtcbiAgaWYgKHBvb2xJdGVtSW5kZXggPiAtMSkge1xuICAgIGNvbXByZXNzaW9uUG9vbFtwb29sSXRlbUluZGV4XS5jYWxsYmFjayhpbWFnZSk7XG4gICAgY2xlYXJUaW1lb3V0KGNvbXByZXNzaW9uUG9vbFtwb29sSXRlbUluZGV4XS50aW1lb3V0KTtcbiAgICBjb21wcmVzc2lvblBvb2wuc3BsaWNlKHBvb2xJdGVtSW5kZXgsIDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RGcmFtZXMoKSB7XG4gIGNvbnN0IHsgY3VycmVudFBhZ2UgfSA9IGZpZ21hO1xuICBjb25zdCByb290RnJhbWVzID0gY3VycmVudFBhZ2UuY2hpbGRyZW4uZmlsdGVyKFxuICAgIChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiRlJBTUVcIlxuICApIGFzIEZyYW1lTm9kZVtdO1xuXG4gIC8vIFJldHVybiBlcnJvciBpZiB0aGVyZSdzIG5vIGZyYW1lcyBvbiB0aGUgY3VycmVudCBwYWdlXG4gIGlmIChyb290RnJhbWVzLmxlbmd0aCA8IDEpIHtcbiAgICBjb25zb2xlLndhcm4oXCJObyBmcmFtZXNcIik7XG4gICAgZmlnbWEudWkucG9zdE1lc3NhZ2UoeyB0eXBlOiBNU0dfRVZFTlRTLk5PX0ZSQU1FUyB9IGFzIE1zZ05vRnJhbWVzVHlwZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGVhZGxpbmVzQW5kU291cmNlID0gZ2V0SGVhZGxpbmVzQW5kU291cmNlKGN1cnJlbnRQYWdlKTtcblxuICBjb25zdCBmcmFtZXNEYXRhID0gcm9vdEZyYW1lcy5tYXAoKGZyYW1lKSA9PiB7XG4gICAgY29uc3QgeyBuYW1lLCB3aWR0aCwgaGVpZ2h0LCBpZCB9ID0gZnJhbWU7XG4gICAgY29uc3QgdGV4dE5vZGVzID0gZ2V0VGV4dE5vZGVzKGZyYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpZCxcbiAgICAgIHRleHROb2RlcyxcbiAgICAgIHJlc3BvbnNpdmU6IGZhbHNlLFxuICAgICAgc2VsZWN0ZWQ6IHRydWUsXG4gICAgfTtcbiAgfSk7XG5cbiAgZmlnbWEudWkucG9zdE1lc3NhZ2Uoe1xuICAgIHR5cGU6IE1TR19FVkVOVFMuRk9VTkRfRlJBTUVTLFxuICAgIGZyYW1lczogZnJhbWVzRGF0YSxcbiAgICB3aW5kb3dXaWR0aDogaW5pdGlhbFdpbmRvd1dpZHRoLFxuICAgIHdpbmRvd0hlaWdodDogaW5pdGlhbFdpbmRvd0hlaWdodCxcbiAgICAuLi5oZWFkbGluZXNBbmRTb3VyY2UsXG4gIH0pO1xufVxuXG4vLyAvLyBUT0RPOiBCcmVhayBvdXQgbmVzdGVkIGFzeW5jIGxvZ2ljXG4vLyBmdW5jdGlvbiBjb21wcmVzc0ltYWdlKG5vZGU6IERlZmF1bHRTaGFwZU1peGluKTogUHJvbWlzZTx2b2lkPiB7XG4vLyAgIGNvbnN0IG5ld0ZpbGxzOiBQYWludFtdID0gW107XG4vLyAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4ge1xuLy8gICAgIGNvbnN0IGZpbGxzID0gbm9kZS5maWxscyA9PT0gZmlnbWEubWl4ZWQgPyBbXSA6IFsuLi5ub2RlLmZpbGxzXTtcblxuLy8gICAgIFByb21pc2UuYWxsKFxuLy8gICAgICAgZmlsbHMubWFwKGFzeW5jIChwYWludCkgPT4ge1xuLy8gICAgICAgICBpZiAocGFpbnQudHlwZSA9PT0gXCJJTUFHRVwiICYmIHBhaW50LmltYWdlSGFzaCkge1xuLy8gICAgICAgICAgIGNvbnN0IGltYWdlID0gZmlnbWEuZ2V0SW1hZ2VCeUhhc2gocGFpbnQuaW1hZ2VIYXNoKTtcbi8vICAgICAgICAgICBjb25zdCBpbWFnZUJ5dGVzID0gYXdhaXQgaW1hZ2UuZ2V0Qnl0ZXNBc3luYygpO1xuLy8gICAgICAgICAgIGNvbnN0IHVpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzIpO1xuXG4vLyAgICAgICAgICAgLy8gU2VuZCBwb3N0IG1lc3NhZ2Vcbi8vICAgICAgICAgICBmaWdtYS51aS5wb3N0TWVzc2FnZSh7XG4vLyAgICAgICAgICAgICB0eXBlOiBNU0dfRVZFTlRTLkNPTVBSRVNTX0lNQUdFLFxuLy8gICAgICAgICAgICAgaW1hZ2U6IGltYWdlQnl0ZXMsXG4vLyAgICAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCxcbi8vICAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQsXG4vLyAgICAgICAgICAgICB1aWQsXG4vLyAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiB7XG4vLyAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4vLyAgICAgICAgICAgICAgIF9yZWplY3QoXCJDb21wcmVzcyBpbWFnZSByZXNwb25zZSB0aW1lZCBvdXQuXCIpO1xuLy8gICAgICAgICAgICAgfSwgNTAwMCk7XG5cbi8vICAgICAgICAgICAgIGNvbXByZXNzaW9uUG9vbC5wdXNoKHtcbi8vICAgICAgICAgICAgICAgdWlkLFxuXG4vLyAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoaW1hZ2U6IFVpbnQ4QXJyYXkpID0+IHtcbi8vICAgICAgICAgICAgICAgICBjb25zdCBuZXdQYWludCA9IHsgLi4ucGFpbnQgfTtcbi8vICAgICAgICAgICAgICAgICBuZXdQYWludC5pbWFnZUhhc2ggPSBmaWdtYS5jcmVhdGVJbWFnZShpbWFnZSkuaGFzaDtcbi8vICAgICAgICAgICAgICAgICBuZXdGaWxscy5wdXNoKG5ld1BhaW50KTtcbi8vICAgICAgICAgICAgICAgICByZXMoKTtcbi8vICAgICAgICAgICAgICAgfSxcblxuLy8gICAgICAgICAgICAgICB0aW1lb3V0LFxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0pXG4vLyAgICAgKVxuLy8gICAgICAgLnRoZW4oKCkgPT4ge1xuLy8gICAgICAgICBub2RlLmZpbGxzID0gbmV3RmlsbHM7XG4vLyAgICAgICAgIHJlc29sdmUoKTtcbi8vICAgICAgIH0pXG4vLyAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuLy8gICAgICAgICBjb25zb2xlLmVycm9yKFwiY29tcHJlc3NpbmcgaW1hZ2VzXCIsIGVycik7XG4vLyAgICAgICB9KTtcbi8vICAgfSk7XG4vLyB9XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihmcmFtZUlkOiBzdHJpbmcpIHtcbiAgLy8gbGV0IGNsb25lO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZnJhbWUgPSBmaWdtYS5nZXROb2RlQnlJZChmcmFtZUlkKTtcbiAgICBpZiAoIWZyYW1lIHx8IGZyYW1lLnR5cGUgIT09IFwiRlJBTUVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBmcmFtZVwiKTtcbiAgICB9XG5cbiAgICAvLyAvLyBmcmFtZS5jbGlwc0NvbnRlbnQgPSB0cnVlO1xuICAgIC8vIGNsb25lID0gZnJhbWUuY2xvbmUoKTtcbiAgICAvLyBjbG9uZS5jbGlwc0NvbnRlbnQgPSB0cnVlO1xuICAgIC8vIGNvbnNvbGUubG9nKFwiY2xpcHBpbmdcIik7XG4gICAgLy8gY2xvbmUubmFtZSA9IGBbdGVtcF0gJHtmcmFtZS5uYW1lfWA7XG5cbiAgICAvLyAvLyBEZWxldGUgZW1wdHkgZGVmIG5vZGVzP1xuICAgIC8vIGNvbnNvbGUubG9nKFxuICAgIC8vICAgZnJhbWUuZmluZEFsbCgobikgPT4ge1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhuKTtcbiAgICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vICAgfSlcbiAgICAvLyApO1xuXG4gICAgLy8gY2xvbmVcbiAgICAvLyAgIC5maW5kQWxsKChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiVEVYVFwiKVxuICAgIC8vICAgLmZvckVhY2goKG5vZGUpID0+IG5vZGUucmVtb3ZlKCkpO1xuXG4gICAgLy8gY29uc3Qgbm9kZXNXaXRoUGFpbnRJbWFnZXMgPSBjbG9uZS5maW5kQWxsKChub2RlKSA9PiB7XG4gICAgLy8gICBpZiAoXCJmaWxsc1wiIGluIG5vZGUgJiYgbm9kZS5maWxscyAhPT0gZmlnbWEubWl4ZWQpIHtcbiAgICAvLyAgICAgcmV0dXJuIG5vZGUuZmlsbHMuc29tZSgoZmlsbCkgPT4gXCJpbWFnZUhhc2hcIiBpbiBmaWxsKTtcbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyAgIH1cbiAgICAvLyB9KSBhcyBEZWZhdWx0U2hhcGVNaXhpbltdO1xuXG4gICAgLy8gYXdhaXQgUHJvbWlzZS5hbGwobm9kZXNXaXRoUGFpbnRJbWFnZXMubWFwKGNvbXByZXNzSW1hZ2UpKTtcblxuICAgIC8vIFdhaXQgZm9yIEZpZ21hIHRvIHByb2Nlc3MgaW1hZ2UgaGFzaCBvdGhlcndpc2UgdGhlIHBhaW50IGZpbGwgd2l0aCBoYXZlXG4gICAgLy8gYW4gaW5jb3JyZWN0IHRyYW5zZm9ybSBzY2FsZVxuICAgIC8vIFRPRE86IEZpbmQgYmV0dGVyIHdheVxuICAgIC8vIGlmIChub2Rlc1dpdGhQYWludEltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgLy8gfVxuXG4gICAgY29uc29sZS5sb2coXCJSRU5ERVJJTkcgU1ZHXCIpO1xuICAgIGNvbnN0IHN2ZyA9IGF3YWl0IGZyYW1lLmV4cG9ydEFzeW5jKHtcbiAgICAgIGZvcm1hdDogXCJTVkdcIixcbiAgICAgIHN2Z091dGxpbmVUZXh0OiBmYWxzZSxcbiAgICAgIHN2Z1NpbXBsaWZ5U3Ryb2tlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLy8gQnVnOiBDbGlwIGNvbnRlbnQgU1ZHIHJlbmRlciBjYW4gcmVzdWx0IGluIGFuIGVtcHR5IGNsaXBQYXRoIHdoaWNoXG4gICAgLy8gbWFza3MgYWxsIGNvbnRlbnQuIEN1cnJlbnQgZml4IGlzIHRvIHNlYXJjaCBmb3IgZW1wdHkgY2xpcCBwYXRocyBhbmRcbiAgICAvLyByZW1vdmUgdGhlbS5cblxuICAgIGZpZ21hLnVpLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IE1TR19FVkVOVFMuUkVOREVSLFxuICAgICAgZnJhbWVJZCxcbiAgICAgIHN2ZyxcbiAgICB9IGFzIE1zZ1JlbmRlclR5cGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBtc2cgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJVbmtub3duIHJlbmRlciBlcnJvclwiO1xuICAgIGZpZ21hLnVpLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IE1TR19FVkVOVFMuRVJST1IsXG4gICAgICBlcnJvclRleHQ6IGBSZW5kZXIgZmFpbGVkOiAke21zZ31gLFxuICAgIH0gYXMgTXNnRXJyb3JUeXBlKTtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHJlbmRlciBTVkdcIiwgZXJyKTtcbiAgfVxufVxuXG4vLyBFeHRyYWN0IG9iamVjdCBwcm9wZXJ0aWVzIGZyb20gdGV4dE5vZGUgZm9yIHBhc3NpbmcgdmlhIHBvc3RNZXNzYWdlXG5mdW5jdGlvbiBnZXRUZXh0Tm9kZXMoZnJhbWU6IEZyYW1lTm9kZSk6IHRleHREYXRhW10ge1xuICBjb25zdCB0ZXh0Tm9kZXMgPSBmcmFtZS5maW5kQWxsKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gXCJURVhUXCIpIGFzIFRleHROb2RlW107XG4gIGNvbnN0IHsgYWJzb2x1dGVUcmFuc2Zvcm0gfSA9IGZyYW1lO1xuICBjb25zdCByb290WCA9IGFic29sdXRlVHJhbnNmb3JtWzBdWzJdO1xuICBjb25zdCByb290WSA9IGFic29sdXRlVHJhbnNmb3JtWzFdWzJdO1xuXG4gIHJldHVybiB0ZXh0Tm9kZXMubWFwKFxuICAgIChub2RlKTogdGV4dERhdGEgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZm9udFNpemU6IGZvbnRTaXplRGF0YSxcbiAgICAgICAgZm9udE5hbWUsXG4gICAgICAgIGZpbGxzLFxuICAgICAgICBjaGFyYWN0ZXJzLFxuICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICBsZXR0ZXJTcGFjaW5nLFxuICAgICAgICB0ZXh0QWxpZ25Ib3Jpem9udGFsLFxuICAgICAgICB0ZXh0QWxpZ25WZXJ0aWNhbCxcbiAgICAgIH0gPSBub2RlO1xuXG4gICAgICAvLyBOT1RFOiBGaWdtYSBub2RlIHgsIHkgYXJlIHJlbGF0aXZlIHRvIGZpcnN0IHBhcmVudCwgd2Ugd2FudCB0aGVtXG4gICAgICAvLyByZWxhdGl2ZSB0byB0aGUgcm9vdCBmcmFtZVxuICAgICAgY29uc3QgdGV4dFggPSBhYnNvbHV0ZVRyYW5zZm9ybVswXVsyXTtcbiAgICAgIGNvbnN0IHRleHRZID0gYWJzb2x1dGVUcmFuc2Zvcm1bMV1bMl07XG4gICAgICBjb25zdCB4ID0gdGV4dFggLSByb290WDtcbiAgICAgIGNvbnN0IHkgPSB0ZXh0WSAtIHJvb3RZO1xuXG4gICAgICAvLyBFeHRyYWN0IGJhc2ljIGZpbGwgY29sb3VyXG4gICAgICBjb25zdCBbZmlsbF0gPSBmaWxscyA9PT0gZmlnbWEubWl4ZWQgPyBbXSA6IGZpbGxzO1xuICAgICAgbGV0IGNvbG91ciA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMSB9O1xuICAgICAgaWYgKGZpbGwudHlwZSA9PT0gXCJTT0xJRFwiKSB7XG4gICAgICAgIGNvbG91ciA9IHsgLi4uY29sb3VyLCBhOiBmaWxsLm9wYWNpdHkgfHwgMSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGZvbnQgaW5mb1xuICAgICAgLy8gVE9ETzogQ29uZmlybSBmYWxsYmFjayBmb250c1xuICAgICAgY29uc3QgZm9udFNpemUgPSBmb250U2l6ZURhdGEgIT09IGZpZ21hLm1peGVkID8gZm9udFNpemVEYXRhIDogMTY7XG4gICAgICBjb25zdCBmb250RmFtaWx5ID0gZm9udE5hbWUgIT09IGZpZ21hLm1peGVkID8gZm9udE5hbWUuZmFtaWx5IDogXCJBcmlhbFwiO1xuICAgICAgY29uc3QgZm9udFN0eWxlID0gZm9udE5hbWUgIT09IGZpZ21hLm1peGVkID8gZm9udE5hbWUuc3R5bGUgOiBcIlJlZ3VsYXJcIjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTdHlsZSxcbiAgICAgICAgY29sb3VyLFxuICAgICAgICBjaGFyYWN0ZXJzLFxuICAgICAgICBsaW5lSGVpZ2h0LFxuICAgICAgICBsZXR0ZXJTcGFjaW5nLFxuICAgICAgICB0ZXh0QWxpZ25Ib3Jpem9udGFsLFxuICAgICAgICB0ZXh0QWxpZ25WZXJ0aWNhbCxcbiAgICAgIH07XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFkbGluZXNBbmRTb3VyY2UocGFnZU5vZGU6IFBhZ2VOb2RlKSB7XG4gIGNvbnN0IE5PREVfTkFNRVMgPSBbXCJoZWFkbGluZVwiLCBcInN1YmhlYWRcIiwgXCJzb3VyY2VcIl07XG5cbiAgY29uc3QgcmVzdWx0OiB7IFtpZDogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH0gPSB7fTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIE5PREVfTkFNRVMpIHtcbiAgICBjb25zdCBub2RlID0gcGFnZU5vZGUuZmluZENoaWxkKFxuICAgICAgKG5vZGUpID0+IG5vZGUubmFtZSA9PT0gbmFtZSAmJiBub2RlLnR5cGUgPT09IFwiVEVYVFwiXG4gICAgKSBhcyBUZXh0Tm9kZSB8IG51bGw7XG5cbiAgICByZXN1bHRbbmFtZV0gPSBub2RlPy5jaGFyYWN0ZXJzO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2V0SGVhZGxpbmVzQW5kU291cmNlKHByb3BzOiBzZXRIZWFkbGluZXNBbmRTb3VyY2VQcm9wcykge1xuICBjb25zdCB7IHBhZ2VOb2RlIH0gPSBwcm9wcztcbiAgY29uc3QgZnJhbWVzID0gcGFnZU5vZGUuZmluZENoaWxkcmVuKChub2RlKSA9PiBub2RlLnR5cGUgPT09IFwiRlJBTUVcIik7XG4gIGNvbnN0IG1vc3RMZWZ0UG9zID0gTWF0aC5taW4oLi4uZnJhbWVzLm1hcCgobm9kZSkgPT4gbm9kZS54KSk7XG4gIGNvbnN0IG1vc3RUb3BQb3MgPSBNYXRoLm1pbiguLi5mcmFtZXMubWFwKChub2RlKSA9PiBub2RlLnkpKTtcblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LnZhbHVlcyhIRUFETElORV9OT0RFX05BTUVTKSkge1xuICAgIGxldCBub2RlID1cbiAgICAgIChwYWdlTm9kZS5maW5kQ2hpbGQoXG4gICAgICAgIChub2RlKSA9PiBub2RlLm5hbWUgPT09IG5hbWUgJiYgbm9kZS50eXBlID09PSBcIlRFWFRcIlxuICAgICAgKSBhcyBUZXh0Tm9kZSkgfHwgbnVsbDtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHByb3BzW25hbWVdO1xuXG4gICAgLy8gUmVtb3ZlIG5vZGUgaWYgdGhlcmUncyBubyB0ZXh0IGNvbnRlbnRcbiAgICBpZiAobm9kZSAmJiAhdGV4dENvbnRlbnQpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0Q29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBub2RlIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5vZGUgPSBmaWdtYS5jcmVhdGVUZXh0KCk7XG4gICAgICBub2RlLm5hbWUgPSBuYW1lO1xuXG4gICAgICBsZXQgeSA9IG1vc3RUb3BQb3MgLSA2MDtcbiAgICAgIGlmIChuYW1lID09PSBIRUFETElORV9OT0RFX05BTUVTLkhFQURMSU5FKSB7XG4gICAgICAgIHkgLT0gNjA7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IEhFQURMSU5FX05PREVfTkFNRVMuU1VCSEVBRCkge1xuICAgICAgICB5IC09IDMwO1xuICAgICAgfVxuXG4gICAgICBub2RlLnJlbGF0aXZlVHJhbnNmb3JtID0gW1xuICAgICAgICBbMSwgMCwgbW9zdExlZnRQb3NdLFxuICAgICAgICBbMCwgMSwgeV0sXG4gICAgICBdO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0ZXh0IG5vZGUgaXMgbG9ja2VkXG4gICAgbm9kZS5sb2NrZWQgPSB0cnVlO1xuXG4gICAgLy8gTG9hZCBmb250XG4gICAgY29uc3QgZm9udE5hbWUgPVxuICAgICAgbm9kZS5mb250TmFtZSAhPT0gZmlnbWEubWl4ZWQgPyBub2RlLmZvbnROYW1lLmZhbWlseSA6IFwiUm9ib3RvXCI7XG4gICAgY29uc3QgZm9udFN0eWxlID1cbiAgICAgIG5vZGUuZm9udE5hbWUgIT09IGZpZ21hLm1peGVkID8gbm9kZS5mb250TmFtZS5zdHlsZSA6IFwiUmVndWxhclwiO1xuICAgIGZpZ21hXG4gICAgICAubG9hZEZvbnRBc3luYyh7IGZhbWlseTogZm9udE5hbWUsIHN0eWxlOiBmb250U3R5bGUgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gU2V0IHRleHQgbm9kZSBjb250ZW50XG4gICAgICAgIG5vZGUuY2hhcmFjdGVycyA9IHByb3BzW25hbWVdIHx8IFwiXCI7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGZvbnRcIiwgZXJyKTtcbiAgICAgIH0pO1xuICB9XG59XG5cbi8vIEhhbmRsZSBtZXNzYWdlcyBmcm9tIHRoZSBVSVxuZnVuY3Rpb24gaGFuZGxlUmVjZWl2ZWRNc2cobXNnOiBQb3N0TXNnKSB7XG4gIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICBjYXNlIE1TR19FVkVOVFMuRVJST1I6XG4gICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IGVycm9yXCIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuQ0xPU0U6XG4gICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IGNsb3NlXCIpO1xuICAgICAgZmlnbWEuY2xvc2VQbHVnaW4oKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBNU0dfRVZFTlRTLkRPTV9SRUFEWTpcbiAgICAgIGNvbnNvbGUubG9nKFwicGx1Z2luIG1zZzogRE9NIFJFQURZXCIpO1xuICAgICAgZ2V0Um9vdEZyYW1lcygpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuUkVOREVSOiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXSVA6IFRFU0lOR1xuICAgICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IHJlbmRlclwiLCBtc2cuZnJhbWVJZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZy5pZHMpO1xuICAgICAgICBjb25zdCB7IGlkcyB9ID0gbXNnO1xuXG4gICAgICAgIGNvbnN0IG91dHB1dE5vZGUgPSBmaWdtYS5jcmVhdGVGcmFtZSgpO1xuICAgICAgICBvdXRwdXROb2RlLm5hbWUgPSBcIm91dHB1dFwiO1xuXG4gICAgICAgIC8vIENsb25lIGVhY2ggc2VsZWN0ZWQgZnJhbWUgYWRkaW5nIHRoZW0gdG8gdGhlIHRlbXAgY29udGFpbmVyIGZyYW1lXG4gICAgICAgIC8vIGF0IG9yaWdpbiAwLDBcbiAgICAgICAgY29uc3QgZnJhbWVzID0gZmlnbWEuY3VycmVudFBhZ2UuY2hpbGRyZW4uZmlsdGVyKCh7IGlkIH0pID0+XG4gICAgICAgICAgaWRzLmluY2x1ZGVzKGlkKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGZyYW1lcyk7XG5cbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLm1heCguLi5mcmFtZXMubWFwKChmKSA9PiBmLndpZHRoKSk7XG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KC4uLmZyYW1lcy5tYXAoKGYpID0+IGYuaGVpZ2h0KSk7XG4gICAgICAgIG91dHB1dE5vZGUucmVzaXplV2l0aG91dENvbnN0cmFpbnRzKG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuXG4gICAgICAgIGZvciAoY29uc3QgZnJhbWUgb2YgZnJhbWVzKSB7XG4gICAgICAgICAgY29uc3QgY2xvbmUgPSBmcmFtZT8uY2xvbmUoKTtcbiAgICAgICAgICBvdXRwdXROb2RlLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgICBjbG9uZS54ID0gMDtcbiAgICAgICAgICBjbG9uZS55ID0gMDtcblxuICAgICAgICAgIGNsb25lLm5hbWUgPSBmcmFtZS5pZDtcblxuICAgICAgICAgIGNvbnNvbGUubG9nKGZyYW1lLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dE5vZGVcbiAgICAgICAgICAuZXhwb3J0QXN5bmMoe1xuICAgICAgICAgICAgZm9ybWF0OiBcIlNWR1wiLFxuICAgICAgICAgICAgc3ZnU2ltcGxpZnlTdHJva2U6IHRydWUsXG4gICAgICAgICAgICBzdmdPdXRsaW5lVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBzdmdJZEF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKChzdmdEYXRhKSA9PiB7XG4gICAgICAgICAgICBmaWdtYS51aS5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIHR5cGU6IE1TR19FVkVOVFMuUkVOREVSLFxuICAgICAgICAgICAgICBzdmdEYXRhLFxuICAgICAgICAgICAgfSBhcyBNc2dSZW5kZXJUeXBlKTtcblxuICAgICAgICAgICAgb3V0cHV0Tm9kZT8ucmVtb3ZlKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgb3V0cHV0Tm9kZT8ucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVuZGVyIHRlbXAgY29udGFpbmVyIGZyYW1lIGFuZCBzZW5kIGJhY2sgY29udGVudFxuXG4gICAgICAgIC8vIGhhbmRsZVJlbmRlcihtc2cuZnJhbWVJZCkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgLy8gICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSByZW5kZXJcIiwgZXJyKVxuICAgICAgICAvLyApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgTVNHX0VWRU5UUy5SRVNJWkU6XG4gICAgICBjb25zb2xlLmxvZyhcInBsdWdpbiBtc2c6IHJlc2l6ZVwiKTtcbiAgICAgIGZpZ21hLnVpLnJlc2l6ZShtc2cud2lkdGgsIG1zZy5oZWlnaHQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuVVBEQVRFX0hFQURMSU5FUzpcbiAgICAgIHNldEhlYWRsaW5lc0FuZFNvdXJjZSh7XG4gICAgICAgIHBhZ2VOb2RlOiBmaWdtYS5jdXJyZW50UGFnZSxcbiAgICAgICAgaGVhZGxpbmU6IG1zZy5oZWFkbGluZSxcbiAgICAgICAgc3ViaGVhZDogbXNnLnN1YmhlYWQsXG4gICAgICAgIHNvdXJjZTogbXNnLnNvdXJjZSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1TR19FVkVOVFMuQ09NUFJFU1NFRF9JTUFHRTpcbiAgICAgIGhhbmRsZUNvbXByZXNzZWRNc2cobXNnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIHBvc3QgbWVzc2FnZVwiLCBtc2cpO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7O0FBQUEsQUFBTyxNQUFLO0FBQUwsWUFBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0tBSlU7QUFPTCxNQUFLO0FBQUwsWUFBSztBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0tBVlU7QUFhTCxNQUFLO0FBQUwsWUFBSztBQUNWO0FBQ0E7S0FGVTtBQStCTCxNQUFLO0FBQUwsWUFBSztBQUNWLHVDQUFXO0FBQ1gsc0NBQVU7QUFDVixxQ0FBUztLQUhDOzs7QUNuRFosQUFhQSxRQUFNLEdBQUcsR0FBRyxXQUFXLENBQUMs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
